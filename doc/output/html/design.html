<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>postgres Operator Design</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta><meta property="og:site_name" content="Crunchy Postgres Operator"></meta><meta property="og:title" content="postgres Operator Design"></meta><meta property="og:type" content="website"></meta><meta property="og:image:type" content="image/png"></meta><meta property="og:image" content="{[backrest-url-base]}/logo.svg"></meta><meta name="description" content="postgres Operator Design"></meta><meta property="og:description" content="postgres Operator Design"></meta><link rel="stylesheet" href="default.css" type="text/css"></link></head><body><div id="header-wrapper"><div class="page-header" id="page-header"><div class="page-header-logo"><img src="logo.svg"></div><div class="page-header-title">postgres Operator Design</div></div><div class="page-menu"><div class="menu-body"><div class="menu"><a class="menu-link" href="configuration.html">Configuration</a></div><div class="menu"><a class="menu-link" href="commands.html">Commands</a></div><div class="menu"><a class="menu-link" href="design.html">Design</a></div><div class="menu"><a class="menu-link" href="install.html">Install</a></div><div class="menu"><a class="menu-link" href="quickstarts.html">Quickstarts</a></div></div></div></div><div id="content-wrapper"><div id="sidebar-wrapper"><div id="sidebar"><div class="page-toc"><div class="page-toc-header"><div class="page-toc-title"></div></div><div class="page-toc-body"><div class="section1-toc"><div class="section1-toc-number">1</div><div class="section1-toc-title"><a href="#_reference_architecture">Reference Architecture</a></div></div><div class="section1-toc"><div class="section1-toc-number">2</div><div class="section1-toc-title"><a href="#_custom_resource_definitions">Custom Resource Definitions</a></div></div><div class="section1-toc"><div class="section1-toc-number">3</div><div class="section1-toc-title"><a href="#_command_line_interface">Command Line Interface</a></div></div><div class="section1-toc"><div class="section1-toc-number">4</div><div class="section1-toc-title"><a href="#_operator_deployment">Operator Deployment</a></div></div><div class="section1-toc"><div class="section1-toc-number">5</div><div class="section1-toc-title"><a href="#_cli_design">CLI Design</a></div><div class="section2-toc"><div class="section2-toc-number">5.1</div><div class="section2-toc-title"><a href="#_cli_design/_verbs">Verbs</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">6</div><div class="section1-toc-title"><a href="#_affinity">Affinity</a></div></div><div class="section1-toc"><div class="section1-toc-number">7</div><div class="section1-toc-title"><a href="#_debugging">Debugging</a></div></div><div class="section1-toc"><div class="section1-toc-number">8</div><div class="section1-toc-title"><a href="#_persistent_volumes">Persistent Volumes</a></div></div><div class="section1-toc"><div class="section1-toc-number">9</div><div class="section1-toc-title"><a href="#_postgresql_operator_deployment_strategies">PostgreSQL Operator Deployment Strategies</a></div><div class="section2-toc"><div class="section2-toc-number">9.1</div><div class="section2-toc-title"><a href="#_postgresql_operator_deployment_strategies/_strategies">Strategies</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.2</div><div class="section2-toc-title"><a href="#_postgresql_operator_deployment_strategies/_specifying_a_strategy">Specifying a Strategy</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.3</div><div class="section2-toc-title"><a href="#_postgresql_operator_deployment_strategies/_strategy_template_files">Strategy Template Files</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.4</div><div class="section2-toc-title"><a href="#_postgresql_operator_deployment_strategies/_default_cluster_deployment_strategy_1">Default Cluster Deployment Strategy (1)</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.5</div><div class="section2-toc-title"><a href="#_postgresql_operator_deployment_strategies/_cluster_deletion">Cluster Deletion</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.6</div><div class="section2-toc-title"><a href="#_postgresql_operator_deployment_strategies/_custom_postgres_configurations">Custom Postgres Configurations</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.7</div><div class="section2-toc-title"><a href="#_postgresql_operator_deployment_strategies/_metrics_collection">Metrics Collection</a></div></div></div></div></div></div></div><div id="page-wrapper"><div id="page-body"><div class="section1"><a id="_reference_architecture"></a><div class="section1-header"><div class="section1-number">1</div><div class="section1-title">Reference Architecture</div></div><div class="section-body"><div class="section-body-text">So, what does the Postgres Operator actually deploy when you create a cluster?</div><div class="imageblock"><img src="../image/OperatorReferenceDiagram.png?raw=true" alt="OperatorReferenceDiagram.png?raw=true" /></div><div class="section-body-text">On this diagram, objects with dashed lines are things that are optionally deployed as part of a Postgres Cluster by the Operator and objects with solid lines are the fundamental and required components.</div><div class="section-body-text">For example, within the Primary Deployment, the <b>metrics</b> container is completely optional, you can deploy that component using Operator configuration or command line arguments if you want to cause metrics to be collected from the Postgres container.</div><div class="section-body-text">Replica deployments are just like the Primary deployment but are optional. You do not have to create a Replica at all unless you need that capability. As you scale up your Postgres cluster, the standard set of components gets deployed and replication to the Primary is started.</div><div class="section-body-text">Lastly, in a future release, you will be able to optionally deploy a Pgpool service and Deployment that can act as a SQL <b>router</b> to your Postgres cluster.</div><div class="section-body-text">Notice that each cluster deployment gets its own unique Persistent Volumes. Each volume can use different storage configurations which is quite powerful.</div></div></div><div class="section1"><a id="_custom_resource_definitions"></a><div class="section1-header"><div class="section1-number">2</div><div class="section1-title">Custom Resource Definitions</div></div><div class="section-body"><div class="section-body-text">Kubernetes Custom Resource Definitions are used in the design of the postgres Operator to define:</div><ul class="list-unordered"><li class="list-unordered">Cluster - <b>pgclusters</b></li><li class="list-unordered">Backup - <b>pgbackups</b></li><li class="list-unordered">Upgrade - <b>pgupgrades</b></li><li class="list-unordered">Policy - <b>pgpolicies</b></li><li class="list-unordered">Tasks - <b>pgtasks</b></li></ul><div class="section-body-text">A PostgreSQL Cluster is made up of multiple Deployments and Services. Optionally you can add a metrics collection container to your database pods.</div></div></div><div class="section1"><a id="_command_line_interface"></a><div class="section1-header"><div class="section1-number">3</div><div class="section1-title">Command Line Interface</div></div><div class="section-body"><div class="section-body-text">The pgo command line interface (CLI) is used by a normal end-user to create databases or clusters, or make changes to existing databases.</div><div class="section-body-text">The CLI interacts interacts with the <b>apiserver</b> REST API deployed within the <b>postgres-operator</b> Deployment.</div><div class="section-body-text">From the CLI, users can view existing clusters that were deployed using the CLI and Operator. Objects that were not created by the Crunchy Operator are now viewable from the CLI.</div></div></div><div class="section1"><a id="_operator_deployment"></a><div class="section1-header"><div class="section1-number">4</div><div class="section1-title">Operator Deployment</div></div><div class="section-body"><div class="section-body-text">The postgres Operator runs within a Deployment in the Kubernetes cluster. An administrator will deploy the postgres Operator Deployment using the provided script. Once installed and running, the Operator pod will start watching for certain defined events.</div><div class="section-body-text">The operator watches for create/update/delete actions on the <b>pgcluster</b> custom resource definitions. When the CLI creates for example a new <b>pgcluster</b> custom resource definition, the operator catches that event and creates pods and services for that new cluster request.</div></div></div><div class="section1"><a id="_cli_design"></a><div class="section1-header"><div class="section1-number">5</div><div class="section1-title">CLI Design</div></div><div class="section-body"><div class="section-body-text">The CLI uses the cobra package to implement CLI functionality like help text, config file processing, and command line parsing.</div><div class="section-body-text">The <b>pgo</b> client is essentially a REST client which communicates to the <b>pgo-apiserver</b> REST server running within the Operator pod. In some cases you might want to split the apiserver out into its own Deployment but the default deployment has a consolidated pod that contains both the apiserver and operator containers simply for convenience of deployment and updates.</div><div class="section2"><a id="_cli_design/_verbs"></a><div class="section2-header"><div class="section2-number">5.1</div><div class="section2-title">Verbs</div></div><div class="section-body"><div class="section-body-text">A user works with the CLI by entering verbs to indicate what they want to do, as follows:</div><pre class="code-block">pgo show cluster all
pgo delete cluster db1 db2 db3
pgo create cluster mycluster</pre><div class="section-body-text">In the above example, the <b>show</b>, <b>backup</b>, <b>delete</b>, and <b>create</b> verbs are used. The CLI is case sensitive and supports only lowercase.</div></div></div></div></div><div class="section1"><a id="_affinity"></a><div class="section1-header"><div class="section1-number">6</div><div class="section1-title">Affinity</div></div><div class="section-body"><div class="section-body-text">You can have the Operator add an affinity section to a new Cluster Deployment if you want to cause Kube to attempt to schedule a Primary cluster to a specific Kube node.</div><div class="section-body-text">You can see the nodes on your Kube cluster by:</div><pre class="code-block">kubectl get nodes</pre><div class="section-body-text">You can then specify one of those names (e.g. kubeadm-node2) when creating a cluster:</div><pre class="code-block">pgo create cluster thatcluster --node-name=kubeadm-node2</pre><div class="section-body-text">The affinity rule inserted in the Deployment will used a <b>preferred</b> strategy so that if the node were down or not available, Kube would go ahead and schedule the Pod on another node.</div><div class="section-body-text">You can always view the actual node your cluster pod is scheduled on by:</div><pre class="code-block">kubectl get pod -o wide</pre><div class="section-body-text">When you scale up a Cluster and add a replica, the scaling will take into account the use of <q>--node-name</q> If it sees that a cluster was created with a specific node name, then the replica Deployment will add an affinity rule to attempt to schedule the replica on a different node than the node the primary is schedule on. This gets you a simple for of High Availability so that your primary and replicas will not live on the same Kube node.</div></div></div><div class="section1"><a id="_debugging"></a><div class="section1-header"><div class="section1-number">7</div><div class="section1-title">Debugging</div></div><div class="section-body"><div class="section-body-text">To see if the operator pod is running enter the following:</div><pre class="code-block">kubectl get pod -l 'name=postgres-operator'</pre><div class="section-body-text">To verify the operator is running and has deployed the Custom Resources execute the following:</div><pre class="code-block">kubectl get crd
NAME                               KIND
pgbackups.cr.client-go.k8s.io      CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgclusters.cr.client-go.k8s.io     CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgpolicies.cr.client-go.k8s.io     CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgpolicylogs.cr.client-go.k8s.io   CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgupgrades.cr.client-go.k8s.io     CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgtasks.cr.client-go.k8s.io        CustomResourceDefinition.v1beta1.apiextensions.k8s.io</pre></div></div><div class="section1"><a id="_persistent_volumes"></a><div class="section1-header"><div class="section1-number">8</div><div class="section1-title">Persistent Volumes</div></div><div class="section-body"><div class="section-body-text">Currently the operator does not delete persistent volumes by default, it will delete the claims on the volumes. Starting with release 2.4, the Operator will create Jobs that actually run <b>rm</b> commands on the data volumes before actually removing the Persistent Volumes if the user passes a <b>--delete-data</b> flag when deleting a database cluster.</div><div class="section-body-text">Likewise, if the user passes <b>--delete-backups</b> during cluster deletion a Job is created to remove all the backups for a cluster include the related Persistent Volume.</div></div></div><div class="section1"><a id="_postgresql_operator_deployment_strategies"></a><div class="section1-header"><div class="section1-number">9</div><div class="section1-title">PostgreSQL Operator Deployment Strategies</div></div><div class="section-body"><div class="section-body-text">This section describes the various deployment strategies offered by the operator. A deployment in this case is the set of objects created in Kubernetes when a custom resource definition of type <b>pgcluster</b> is created. CRDs are created by the pgo client command and acted upon by the postgres operator.</div><div class="section2"><a id="_postgresql_operator_deployment_strategies/_strategies"></a><div class="section2-header"><div class="section2-number">9.1</div><div class="section2-title">Strategies</div></div><div class="section-body"><div class="section-body-text">To support different types of deployments, the operator supports multiple strategy implementations. Currently there is only a default <b>cluster</b> strategy.</div><div class="section-body-text">In the future, more deployment strategies will be supported to offer users more customization to what they see deployed in their Kube cluster.</div><div class="section-body-text">Being open source, users can also write their own strategy!</div></div></div><div class="section2"><a id="_postgresql_operator_deployment_strategies/_specifying_a_strategy"></a><div class="section2-header"><div class="section2-number">9.2</div><div class="section2-title">Specifying a Strategy</div></div><div class="section-body"><div class="section-body-text">In the pgo client configuration file, there is a <b>CLUSTER.STRATEGY</b> setting. The current value of the default strategy is <b>1</b>. If you don't set that value, the default strategy is assumed. If you set that value to something not supported, the operator will log an error.</div></div></div><div class="section2"><a id="_postgresql_operator_deployment_strategies/_strategy_template_files"></a><div class="section2-header"><div class="section2-number">9.3</div><div class="section2-title">Strategy Template Files</div></div><div class="section-body"><div class="section-body-text">Each strategy supplies its set of templates used by the operator to create new pods, services, etc.</div><div class="section-body-text">When the operator is deployed, part of the deployment process is to copy the required strategy templates into a ConfigMap (<b>operator-conf</b>) that gets mounted into <b>/operator-conf</b> within the operator pod.</div><div class="section-body-text">The directory structure of the strategy templates is as follows:</div><pre class="code-block">|-- backup-job.json
|-- cluster
|   |-- 1
|       |-- cluster-deployment-1.json
|       |-- cluster-replica-deployment-1.json
|       |-- cluster-service-1.json
|
|-- pvc.json</pre><div class="section-body-text">In this structure, each strategy's templates live in a subdirectory that matches the strategy identifier. The default strategy templates are denoted by the value of <b>1</b> in the directory structure above.</div><div class="section-body-text">If you add another strategy, the file names <b>must</b> be unique within the entire strategy directory. This is due to the way the templates are stored within the ConfigMap.</div></div></div><div class="section2"><a id="_postgresql_operator_deployment_strategies/_default_cluster_deployment_strategy_1"></a><div class="section2-header"><div class="section2-number">9.4</div><div class="section2-title">Default Cluster Deployment Strategy (1)</div></div><div class="section-body"><div class="section-body-text">Using the default cluster strategy, a <b>cluster</b> when created by the operator will create the following on a Kube cluster:</div><ul class="list-unordered"><li class="list-unordered">deployment running a Postgres <b>primary</b> container with replica count of 1</li><li class="list-unordered">service mapped to the <b>primary</b> Postgres database</li><li class="list-unordered">service mapped to the <b>replica</b> Postgres database</li><li class="list-unordered">PVC for the <b>primary</b> will be created if not specified in configuration, this assumes you are using a non-shared volume technology (e.g. Amazon EBS), if the CLUSTER.PVC_NAME value is set in your configuration then a shared volume technology is assumed (e.g. HostPath or NFS), if a PVC is created for the primary, the naming convention is <b>clustername-pvc</b> where clustername is the name of your cluster.</li></ul><div class="section-body-text">If you want to add a Postgres replica to a cluster, you will <b>scale</b> the cluster, for each <b>replica-count</b>, a Deployment will be created that acts as a Postgres replica.</div><div class="section-body-text">This is very different than using say a StatefulSet to scale up Postgres. Why would I do it this way? Imagine a case where you want different parts of your Postgres cluster to use different storage configurations, I can do that by doing specific placement and deployments of each part of the cluster.</div><div class="section-body-text">This same concept applies to node selection for your Postgres cluster components. The Operator will let you define precisely which node you want each Postgres component to be placed upon using node affinity rules.</div></div></div><div class="section2"><a id="_postgresql_operator_deployment_strategies/_cluster_deletion"></a><div class="section2-header"><div class="section2-number">9.5</div><div class="section2-title">Cluster Deletion</div></div><div class="section-body"><div class="section-body-text">When you run the following:</div><pre class="code-block">pgo delete cluster mycluster</pre><div class="section-body-text">The cluster and its services will be deleted. However the data files and backup files will remain, same with the PVCs for this cluster, they all remain.</div><div class="section-body-text">However, to remove the data files from the PVC you can pass a flag:</div><pre class="code-block">--delete-data</pre><div class="section-body-text">which will cause a workflow to be started to actually remove the data files on the primary cluster deployment PVC.</div><div class="section-body-text">Also, if you pass a flag:</div><pre class="code-block">--delete-backups</pre><div class="section-body-text">it will cause <b>all</b> the backup files to be removed.</div><div class="section-body-text">The data removal workflow includes the following steps:</div><ul class="list-unordered"><li class="list-unordered">create a pgtask CRD to hold the PVC name and cluster name to be removed</li><li class="list-unordered">the CRD is watched, and on an ADD will cause a Job to be created that will run the <b>rmdata</b> container using the PVC name and cluster name as parameters which determine the PVC to mount, and the file path to remove under that PVC</li><li class="list-unordered">the <b>rmdata</b> Job is watched by the Operator, and upon a successful status completion the actual PVC is removed</li></ul><div class="section-body-text">This workflow insures that a PVC is not removed until all the data files are removed. Also, a Job was used for the removal of files since that can be a time consuming task.</div><div class="section-body-text">The files are removed by the <b>rmdata</b> container which essentially issues the following command to remove the files:</div><pre class="code-block">rm -rf /pgdata/<some path></pre></div></div><div class="section2"><a id="_postgresql_operator_deployment_strategies/_custom_postgres_configurations"></a><div class="section2-header"><div class="section2-number">9.6</div><div class="section2-title">Custom Postgres Configurations</div></div><div class="section-body"><div class="section-body-text">Starting in release 2.5, users and administrators can specify a custom set of Postgres configuration files be used when creating a new Postgres cluster. The configuration files you can change include:</div><ul class="list-unordered"><li class="list-unordered">postgresql.conf</li><li class="list-unordered">pg_hba.conf</li><li class="list-unordered">setup.sql</li></ul><div class="section-body-text">Different configurations for Postgres might be defined for the following:</div><ul class="list-unordered"><li class="list-unordered">OLTP types of databases</li><li class="list-unordered">OLAP types of databases</li><li class="list-unordered">High Memory</li><li class="list-unordered">Minimal Configuration for Development</li><li class="list-unordered">Project Specific configurations</li><li class="list-unordered">Special Security Requirements</li></ul><div class="section3"><a id="_postgresql_operator_deployment_strategies/_custom_postgres_configurations/_global_configmap"></a><div class="section3-header"><div class="section3-number">9.6.1</div><div class="section3-title">Global ConfigMap</div></div><div class="section-body"><div class="section-body-text">If you create a <b>configMap</b> called <b>pgo-custom-pg-config</b> with any of the above files within it, new clusters will use those configuration files when setting up a new database instance. You do <b>NOT</b> have to specify all of the configuration files, its up to your use case which ones to use.</div><div class="section-body-text">An example set of configuration files and a script to create the global configMap is found at:</div><pre class="code-block">$COROOT/examples/custom-config</pre><div class="section-body-text">If you run the <b>create.sh</b> script there, it will create the configMap that will include the Postgres configuration files within that directory.</div></div></div><div class="section3"><a id="_postgresql_operator_deployment_strategies/_custom_postgres_configurations/_config_files_purpose"></a><div class="section3-header"><div class="section3-number">9.6.2</div><div class="section3-title">Config Files Purpose</div></div><div class="section-body"><div class="section-body-text">The <b>postgresql.conf</b> file is the main Postgresql configuration file allowing you to define a wide variety of tuning parameters and features.</div><div class="section-body-text">The <b>pg_hba.conf</b> file is the way Postgresql secures down client access.</div><div class="section-body-text">The <b>setup.sql</b> file is a Crunchy Container Suite configuration file used to initially populate the database after the initial <b>initdb</b> is run when the database is first created. You would make changes to this if you wanted to define what database objects always are created.</div></div></div><div class="section3"><a id="_postgresql_operator_deployment_strategies/_custom_postgres_configurations/_granular_config_maps"></a><div class="section3-header"><div class="section3-number">9.6.3</div><div class="section3-title">Granular Config Maps</div></div><div class="section-body"><div class="section-body-text">So, lets say you want to use a different set of configuration files for different clusters instead of having just a single configuration (e.g. Global Config Map). You can create your own set of ConfigMaps with their own set of Postgresql configuration files. When creating new clusters, you can pass a <b>--custom-config</b> flag along with the name of your ConfigMap and that will be used for that specific cluster or set of clusters.</div></div></div><div class="section3"><a id="_postgresql_operator_deployment_strategies/_custom_postgres_configurations/_default"></a><div class="section3-header"><div class="section3-number">9.6.4</div><div class="section3-title">Default</div></div><div class="section-body"><div class="section-body-text">Lets say you are happy with the default Postgresql configuration files that ship with the Crunchy Postgres container. You don't have to do anything essentially, just keep using the Operator as normal. Just be sure to not define a global configMap or pass the command line flag.</div></div></div><div class="section3"><a id="_postgresql_operator_deployment_strategies/_custom_postgres_configurations/_labeling"></a><div class="section3-header"><div class="section3-number">9.6.5</div><div class="section3-title">Labeling</div></div><div class="section-body"><div class="section-body-text">You will notice that when a custom configMap is used in cluster creation, the Operator labels the primary Postgres Deployment with a label that hase a <b>custom-config</b> label and a value of what configMap was used when creating the database.</div><div class="section-body-text">Commands coming in future releases will take advantage of this labeling.</div></div></div></div></div><div class="section2"><a id="_postgresql_operator_deployment_strategies/_metrics_collection"></a><div class="section2-header"><div class="section2-number">9.7</div><div class="section2-title">Metrics Collection</div></div><div class="section-body"><div class="section-body-text">If you add a <b>--metrics</b> flag to <b>pgo create cluster</b> it will cause the <b>crunchy-collect</b> container to be added to your Postgres cluster.</div><div class="section-body-text">That container requires you run the <b>crunchy-metrics</b> containers as defined within the <b>crunchy-containers</b> project.</div><div class="section-body-text">The <b>prometheus push gateway</b> that is deployed as part of the <b>crunchy-metrics</b> example is a current requirement for the metrics solution. This will change in an upcoming release of the <b>crunchy-containers</b> project and there will no longer be a requirement for the push gateway to be deployed.</div><div class="section-body-text">See <a href="https://github.com/CrunchyData/crunchy-containers/blob/master/docs/metrics.adoc">https://github.com/CrunchyData/crunchy-containers/blob/master/docs/metrics.adoc</a> and <a href="https://github.com/CrunchyData/crunchy-containers/blob/master/docs/examples.adoc#metrics-collection">https://github.com/CrunchyData/crunchy-containers/blob/master/docs/examples.adoc#metrics-collection</a> for more details on setting up the <b>crunchy-metrics</b> solution.</div></div></div></div></div><div class="page-footer text-center">Prepared by Crunchy Data Solutions, Inc. &mdash; April 5, 2018</div></div></div></div></body></html>