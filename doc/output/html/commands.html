<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>PostgreSQL Operator Commands</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta><meta property="og:site_name" content="Crunchy Postgres Operator"></meta><meta property="og:title" content="PostgreSQL Operator Commands"></meta><meta property="og:type" content="website"></meta><meta property="og:image:type" content="image/png"></meta><meta property="og:image" content="{[backrest-url-base]}/logo.svg"></meta><meta name="description" content="PostgreSQL Operator Commands"></meta><meta property="og:description" content="PostgreSQL Operator Commands"></meta><link rel="stylesheet" href="default.css" type="text/css"></link></head><body><div id="header-wrapper"><div class="page-header" id="page-header"><div class="page-header-logo"><img src="logo.svg"></div><div class="page-header-title">PostgreSQL Operator Commands</div></div><div class="page-menu"><div class="menu-body"><div class="menu"><a class="menu-link" href="configuration.html">Configuration</a></div><div class="menu"><a class="menu-link" href="commands.html">Commands</a></div><div class="menu"><a class="menu-link" href="design.html">Design</a></div><div class="menu"><a class="menu-link" href="install.html">Install</a></div><div class="menu"><a class="menu-link" href="quickstarts.html">Quickstarts</a></div></div></div></div><div id="content-wrapper"><div id="sidebar-wrapper"><div id="sidebar"><div class="page-toc"><div class="page-toc-header"><div class="page-toc-title"></div></div><div class="page-toc-body"><div class="section1-toc"><div class="section1-toc-number">1</div><div class="section1-toc-title"><a href="#_pgo_commands">pgo Commands</a></div><div class="section2-toc"><div class="section2-toc-number">1.1</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_version">pgo version</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.2</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_create_cluster">pgo create cluster</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.3</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_backup">pgo backup</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.4</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_delete_backup">pgo delete backup</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.5</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_delete_cluster">pgo delete cluster</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.6</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_scale">pgo scale</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.7</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_upgrade">pgo upgrade</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.8</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_delete_upgrade">pgo delete upgrade</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.9</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_show_pvc">pgo show pvc</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.10</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_show_cluster">pgo show cluster</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.11</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_test">pgo test</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.12</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_create_policy">pgo create policy</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.13</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_delete_policy">pgo delete policy</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.14</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_apply">pgo apply</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.15</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_user">pgo user</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.16</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_label">pgo label</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.17</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_load">pgo load</a></div></div><div class="section2-toc"><div class="section2-toc-number">1.18</div><div class="section2-toc-title"><a href="#_pgo_commands/_pgo_failover">pgo failover</a></div></div></div></div></div></div></div><div id="page-wrapper"><div id="page-body"><div class="section1"><a id="_pgo_commands"></a><div class="section1-header"><div class="section1-number">1</div><div class="section1-title">pgo Commands</div></div><div class="section-body"><div class="section-body-text">Prior to using <b>pgo</b>, users will need to specify the <b>postgres-operator</b> URL as follows:</div><pre class="code-block">kubectl get service postgres-operator
NAME                CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
postgres-operator   10.104.47.110   <none>        8443/TCP   7m
export CO_APISERVER_URL=https://10.104.47.110:8443
pgo version</pre><div class="section2"><a id="_pgo_commands/_pgo_version"></a><div class="section2-header"><div class="section2-number">1.1</div><div class="section2-title">pgo version</div></div><div class="section-body"><div class="section-body-text">To see what version of pgo client and postgres-operator you are running, use the following:</div><pre class="code-block">pgo version</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_create_cluster"></a><div class="section2-header"><div class="section2-number">1.2</div><div class="section2-title">pgo create cluster</div></div><div class="section-body"><div class="section-body-text">To create a database, use the following:</div><pre class="code-block">pgo create cluster mycluster</pre><div class="section-body-text">A more complex example is to create a <b>series</b> of clusters such as:</div><pre class="code-block">pgo create cluster xraydb --series=3 --labels=project=xray --policies=xrayapp,rlspolicy</pre><div class="section-body-text">In the example above, we provision 3 clusters that have a number appended into their resulting cluster name, apply a user defined label to each cluster, and also apply user defined policies to each cluster after they are created.</div><div class="section-body-text">You can then view that database as:</div><pre class="code-block">pgo show cluster mydatabase</pre><div class="section-body-text">Also, if you like to see JSON formatted output, add the <b>-o json</b> flag:</div><pre class="code-block">pgo show cluster mydatabase -o json</pre><div class="section-body-text">The output will give you the current status of the database pod and the IP address of the database service. If you have <b>postgresql</b> installed on your test system you can connect to the database using the service IP address:</div><pre class="code-block">psql -h 10.105.121.12 -U postgres postgres</pre><div class="section-body-text">More details are available on user management below, however, you may wish to take note that user credentials are created in the file $COROOT/deploy/create-secrets.sh upon deployment of the Operator. The following user accounts and passwords are created by default for connecting to the PostgreSQL clusters:</div><div class="section-body-text"><b>username</b>: postgres <b>password</b>: password</div><div class="section-body-text"><b>username</b>: primaryuser <b>password</b>: password</div><div class="section-body-text"><b>username</b>: testuser <b>password</b>: password</div><div class="section-body-text">You can view <b>all</b> databases using the special keyword <b>all</b>:</div><pre class="code-block">pgo show cluster all</pre><div class="section-body-text">You can filter the results based on the Postgres Version:</div><pre class="code-block">pgo show cluster all --version=9.6.2</pre><div class="section-body-text">You can also add metrics collection to a cluster by using the <b>--metrics</b> command flag as follows:</div><pre class="code-block">pgo create cluster testcluster --metrics</pre><div class="section-body-text">This command flag causes a <b>crunchy-collect</b> container to be added to the database cluster pod and enables metrics collection on that database pod. For this to work, you will need to configure the Crunchy metrics example as found in the Crunchy Container Suite.</div><div class="section-body-text">New clusters typically pick up the container image version to use based on the <b>pgo</b> configuration file's CCP_IMAGE_TAG setting. You can override this value using the <b>--ccp-image-tag</b> command line flag:</div><pre class="code-block">pgo create cluster mycluster --ccp-image-tag=centos7-9.6.5-1.6.0</pre><div class="section-body-text">You can also add a pgpool deployment into a cluster by using the <b>--pgpool</b> command flag as follows:</div><pre class="code-block">pgo create cluster testcluster --pgpool</pre><div class="section-body-text">This will cause a <b>crunchy-pgpool</b> container to be started and initially configured for a cluster and the <b>testuser</b> cluster credential. See below for more details on running a pgpool deployment as part of your cluster.</div></div></div><div class="section2"><a id="_pgo_commands/_pgo_backup"></a><div class="section2-header"><div class="section2-number">1.3</div><div class="section2-title">pgo backup</div></div><div class="section-body"><div class="section-body-text">You can start a backup job for a cluster as follows:</div><pre class="code-block">pgo backup mycluster</pre><div class="section-body-text">You can view the backup:</div><pre class="code-block">pgo show backup mycluster</pre><div class="section-body-text">View the PVC folder and the backups contained therein:</div><pre class="code-block">pgo show pvc mycluster-backup-pvc
pgo show pvc mycluster-backup-pvc --pvc-root=mycluster-backups</pre><div class="section-body-text">The output from this command is important in that it can let you copy/paste a backup snapshot path and use it for restoring a database or essentially cloning a database with an existing backup archive.</div><div class="section-body-text">For example, to restore a database from a backup archive:</div><pre class="code-block">pgo create cluster restoredb --backup-path=mycluster-backups/2017-03-27-13-56-49 --backup-pvc=mycluster-pvc --secret-from=mycluster</pre><div class="section-body-text">This will create a new database called <b>restoredb</b> based on the backup found in <b>mycluster-backups/2017-03-27-13-56-49</b> and the secrets of the <b>mycluster</b> cluster.</div><div class="section-body-text">Selectors can be used to perform backups as well, for example:</div><pre class="code-block">pgo backup  --selector=project=xray</pre><div class="section-body-text">In this example, any cluster that matches the selector will cause a backup job to be created.</div><div class="section-body-text">When you request a backup, <b>pgo</b> will prompt you if you want to proceed because this action will delete any existing backup job for this cluster that might exist. The backup files will still be left intact but the actual Kubernetes Job will be removed prior to creating a new Job with the same name.</div></div></div><div class="section2"><a id="_pgo_commands/_pgo_delete_backup"></a><div class="section2-header"><div class="section2-number">1.4</div><div class="section2-title">pgo delete backup</div></div><div class="section-body"><div class="section-body-text">To delete a backup enter the following:</div><pre class="code-block">pgo delete backup mybackup</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_delete_cluster"></a><div class="section2-header"><div class="section2-number">1.5</div><div class="section2-title">pgo delete cluster</div></div><div class="section-body"><div class="section-body-text">You can remove a cluster by running:</div><pre class="code-block">pgo delete cluster restoredb</pre><div class="section-body-text">Note, that this command will not remove the PVC associated with this cluster.</div><div class="section-body-text">Selectors also apply to the delete command as follows:</div><pre class="code-block">pgo delete cluster  --selector=project=xray</pre><div class="section-body-text">This command will cause any cluster matching the selector to be removed.</div><div class="section-body-text">You can remove a cluster and it's data files by running:</div><pre class="code-block">pgo delete cluster restoredb --delete-data</pre><div class="section-body-text">You can remove a cluster, it's data files, and all backups by running:</div><pre class="code-block">pgo delete cluster restoredb --delete-data --delete-backups</pre><div class="section-body-text">When you specify a destructive delete like above, you will be prompted to make sure this is what you want to do. If you don't want to be prompted you can enter the <b>--no-prompt</b> command line flag.</div></div></div><div class="section2"><a id="_pgo_commands/_pgo_scale"></a><div class="section2-header"><div class="section2-number">1.6</div><div class="section2-title">pgo scale</div></div><div class="section-body"><div class="section-body-text">When you create a Cluster, you will see in the output a variety of Kubernetes objects were created including:</div><ul class="list-unordered"><li class="list-unordered">a Deployment holding the primary PostgreSQL database</li><li class="list-unordered">a Deployment holding the replica PostgreSQL database</li><li class="list-unordered">a service for the primary database</li><li class="list-unordered">a service for the replica databases</li></ul><div class="section-body-text">Since Postgres is a single-primary database by design, the primary Deployment is set to a replica count of 1, it can not scale beyond 1.</div><div class="section-body-text">With Postgres, you can any n-number of replicas each of which connect to the primary forming a streaming replication postgres cluster. The Postgres replicas are read-only, whereas the primary is read-write. To create a Postgres replica enter a command such as:</div><pre class="code-block">pgo scale mycluster</pre><div class="section-body-text">The <b>pgo scale</b> command is additive, in that each time you execute it, it will create another replica which is added to the Postgres cluster.</div><div class="section-body-text">There are 2 service connections available to the PostgreSQL cluster. One is to the primary database which allows read-write SQL processing, and the other is to the set of read-only replica databases. The replica service performs round-robin load balancing to the replica databases.</div><div class="section-body-text">You can connect to the primary database and verify that it is replicating to the replica databases as follows:</div><pre class="code-block">psql -h 10.107.180.159 -U postgres postgres -c 'table pg_stat_replication'</pre><div class="section-body-text">You can view <b>all</b> clusters using the special keyword <b>all</b>:</div><pre class="code-block">pgo show cluster all</pre><div class="section-body-text">You can filter the results by Postgres version:</div><pre class="code-block">pgo show cluster all --version=9.6.2</pre><div class="section-body-text">The scale command will let you specify a <b>--node-label</b> flag which can be used to influence what Kube node the replica will be scheduled upon.</div><pre class="code-block">pgo scale mycluster --node-label=speed=fast</pre><div class="section-body-text">If you don't specify a <b>--node-label</b> flag, a node affinity rule of <b>NotIn</b> will be specified to <b>prefer</b> that the replica be schedule on a node that the primary is not running on.</div><div class="section-body-text">You can also dictate what container resource and storage configurations will be used for a replica by passing in extra command flags:</div><pre class="code-block">pgo scale mycluster --storage-config=storage1 --resources-config=small</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_upgrade"></a><div class="section2-header"><div class="section2-number">1.7</div><div class="section2-title">pgo upgrade</div></div><div class="section-body"><div class="section-body-text">You can perform a minor Postgres version upgrade of either a database or cluster as follows:</div><pre class="code-block">pgo upgrade mycluster</pre><div class="section-body-text">When you run this command, it will cause the operator to delete the existing containers of the database or cluster and recreate them using the currently defined Postgres container image specified in your pgo configuration file.</div><div class="section-body-text">The database data files remain untouched, only the container is updated, this will upgrade your Postgres server version only.</div><div class="section-body-text">You can perform a major Postgres version upgrade of either a database or cluster as follows:</div><pre class="code-block">pgo upgrade mycluster --upgrade-type=major</pre><div class="section-body-text">When you run this command, it will cause the operator to delete the existing containers of the database or cluster and recreate them using the currently defined Postgres container image specified in your pgo configuration file.</div><div class="section-body-text">The database data files are converted to the new major Postgres version as specified by the current Postgres image version in your pgo configuration file.</div><div class="section-body-text">In this scenario, the upgrade is performed by the Postgres pg_upgrade utility which is containerized in the <b>crunchydata/crunchy-upgrade</b> container. The operator will create a Job which runs the upgrade container, using the existing Postgres database files as input, and output the updated database files to a new PVC.</div><div class="section-body-text">Once the upgrade job is completed, the operator will create the original database or cluster container mounted with the new PVC which contains the upgraded database files.</div><div class="section-body-text">As the upgrade is processed, the status of the <b>pgupgrade</b> CRD is updated to give the user some insight into how the upgrade is proceeding. Upgrades like this can take a long time if your database is large. The operator creates a watch on the upgrade job to know when and how to proceed.</div><div class="section-body-text">Likewise, you can upgrade the cluster using a command line flag:</div><pre class="code-block">pgo upgrade mycluster --ccp-image-tag=centos7-9.6.8-1.8.1
pgo upgrade mycluster --upgrade-type=major --ccp-image-tag=centos7-9.6.8-1.8.1</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_delete_upgrade"></a><div class="section2-header"><div class="section2-number">1.8</div><div class="section2-title">pgo delete upgrade</div></div><div class="section-body"><div class="section-body-text">To remove an upgrade CRD, issue the following:</div><pre class="code-block">pgo delete upgrade</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_show_pvc"></a><div class="section2-header"><div class="section2-number">1.9</div><div class="section2-title">pgo show pvc</div></div><div class="section-body"><div class="section-body-text">You can view the files on a PVC as follows:</div><pre class="code-block">pgo show pvc mycluster-pvc</pre><div class="section-body-text">In this example, the PVC is <b>mycluster-pvc</b>. This command is useful in some cases to examine what files are on a given PVC.</div><div class="section-body-text">In the case where you want to list a specific path on a PVC you can specify the path option as follows:</div><pre class="code-block">pgo show pvc mycluster-pvc --pvc-root=mycluster-backups</pre><div class="section-body-text">You can also list all PVCs that are created by the operator using:</div><pre class="code-block">pgo show pvc all</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_show_cluster"></a><div class="section2-header"><div class="section2-number">1.10</div><div class="section2-title">pgo show cluster</div></div><div class="section-body"><div class="section-body-text">You can view the passwords used by the cluster as follows:</div><pre class="code-block">pgo show cluster mycluster --show-secrets=true</pre><div class="section-body-text">Passwords are generated if not specified in your <b>pgo</b> configuration.</div></div></div><div class="section2"><a id="_pgo_commands/_pgo_test"></a><div class="section2-header"><div class="section2-number">1.11</div><div class="section2-title">pgo test</div></div><div class="section-body"><div class="section-body-text">You can test the database connections to a cluster:</div><pre class="code-block">pgo test mycluster</pre><div class="section-body-text">This command will test each service defined for the cluster using the postgres, primary, and normal user accounts defined for the cluster. The cluster credentials are accessed and used to test the database connections. The equivalent <b>psql</b> command is printed out as connections are tried, along with the connection status.</div><div class="section-body-text">Like other commands, you can use the selector to test a series of clusters:</div><pre class="code-block">pgo test --selector=env=research
pgo test all</pre><div class="section-body-text">You can get output using the <b>--output</b> flag:</div><pre class="code-block">pgo test all -o json</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_create_policy"></a><div class="section2-header"><div class="section2-number">1.12</div><div class="section2-title">pgo create policy</div></div><div class="section-body"><div class="section-body-text">To create a policy use the following syntax:</div><pre class="code-block">pgo create policy policy1 --in-file=/tmp/policy1.sql
pgo create policy policy1 --url=https://someurl/policy1.sql</pre><div class="section-body-text">When you execute this command, it will create a policy named <b>policy1</b> using the input file <b>/tmp/policy1.sql</b> as input. It will create on the server a PgPolicy CRD with the name <b>policy1</b> that you can examine as follows:</div><pre class="code-block">kubectl get pgpolicies policy1 -o json</pre><div class="section-body-text">Policies get automatically applied to any cluster you create if you define in your <b>pgo.yaml</b> configuration a CLUSTER.POLICIES value. Policy SQL is executed as the <b>postgres</b> user.</div><div class="section-body-text">To view policies:</div><pre class="code-block">pgo show policy all</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_delete_policy"></a><div class="section2-header"><div class="section2-number">1.13</div><div class="section2-title">pgo delete policy</div></div><div class="section-body"><div class="section-body-text">To delete a policy use the following form:</div><pre class="code-block">pgo delete policy policy1</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_apply"></a><div class="section2-header"><div class="section2-number">1.14</div><div class="section2-title">pgo apply</div></div><div class="section-body"><div class="section-body-text">To apply an existing policy to a set of clusters, issue a command like this:</div><pre class="code-block">pgo apply policy1 --selector=name=mycluster</pre><div class="section-body-text">When you execute this command, it will look up clusters that have a label value of <b>name=mycluster</b> and then it will apply the <b>policy1</b> label to that cluster and execute the policy SQL against that cluster using the <b>postgres</b> user account.</div><div class="admonition"><div class="warning">WARNING:</div><div class="warning-text">policies are executed as the superuser in PostgreSQL therefore take caution when using them.</div></div><div class="section-body-text">If you want to view the clusters than have a specific policy applied to them, you can use the <b>--selector</b> flag as follows to filter on a policy name (e.g. policy1):</div><pre class="code-block">pgo show cluster --selector=policy1=pgpolicy</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_user"></a><div class="section2-header"><div class="section2-number">1.15</div><div class="section2-title">pgo user</div></div><div class="section-body"><div class="section-body-text">To create a new Postgres user to the <b>mycluster</b> cluster, execute:</div><pre class="code-block">pgo createa user sally --selector=name=mycluster</pre><div class="section-body-text">To delete a Postgres user in the <b>mycluster</b> cluster, execute:</div><pre class="code-block">pgo user --delete-user=sally --selector=name=mycluster</pre><div class="section-body-text">To delete that user in all clusters:</div><pre class="code-block">pgo user --delete-user=sally</pre><div class="section-body-text">To change the password for a user in the <b>mycluster</b> cluster:</div><pre class="code-block">pgo user --change-password=sally --selector=name=mycluster</pre><div class="section-body-text">The password is generated and applied to the user sally.</div><div class="section-body-text">To see user passwords that have expired past a certain number of days in the <b>mycluster</b> cluster:</div><pre class="code-block">pgo user --expired=7 --selector=name=mycluster</pre><div class="section-body-text">To assign users to a cluster:</div><pre class="code-block">pgo create user user1 --valid-days=30 --managed --db=userdb --selector=name=xraydb1</pre><div class="section-body-text">In this example, a user named <b>user1</b> is created with a <b>valid until</b> password date set to expire in 30 days. That user will be granted access to the <b>userdb</b> database. This user account also will have an associated <b>secret</b> created to hold the password that was generated for this user. Any clusters that match the selector value will have this user created on it.</div><div class="section-body-text">To change a user password:</div><pre class="code-block">pgo user --change-password=user1 --valid-days=10 --selector=name=xray1</pre><div class="section-body-text">In this example, a user named <b>user1</b> has its password changed to a generated value and the <b>valid until</b> expiration date set to 10 days from now, this command will take effect across all clusters that match the selector. If you specify <b>valid-days=-1</b> it will mean the password will not expire (e.g. infinity).</div><div class="section-body-text">To drop a user:</div><pre class="code-block">pgo user --delete-user=user3   --selector=project=xray</pre><div class="section-body-text">To see which passwords are set to expire in a given number of days:</div><pre class="code-block">pgo user --expired=10  --selector=project=xray</pre><div class="section-body-text">In this example, any clusters that match the selector are queried to see if any users are set to expire in 10 days.</div><div class="section-body-text">To update expired passwords in a cluster:</div><pre class="code-block">pgo user --update-passwords --selector=name=mycluster</pre></div></div><div class="section2"><a id="_pgo_commands/_pgo_label"></a><div class="section2-header"><div class="section2-number">1.16</div><div class="section2-title">pgo label</div></div><div class="section-body"><div class="section-body-text">You can apply a user defined label to a cluster as follows:</div><pre class="code-block">pgo label --label=env=research  --selector=project=xray</pre><div class="section-body-text">In this example, we apply a label of <b>env=research</b> to any clusters that have an existing label of <b>project=xray</b> applied.</div></div></div><div class="section2"><a id="_pgo_commands/_pgo_load"></a><div class="section2-header"><div class="section2-number">1.17</div><div class="section2-title">pgo load</div></div><div class="section-body"><div class="section-body-text">A CSV file loading capability is supported currently. You can test that by creating a SQL Policy which will create a database table that will be loaded with the CSV data. For example:</div><pre class="code-block">pgo create policy xrayapp --in-file=$COROOT/examples/policy/xrayapp.sql</pre><div class="section-body-text">Then you can load a sample CSV file into a database as follows:</div><pre class="code-block">pgo load --load-config=$COROOT/examples/sample-load-config.json  --selector=name=mycluster</pre><div class="section-body-text">The loading is based on a load definition found in the <b>sample-load-config.json</b> file. In that file, the data to be loaded is specified. When the <b>pgo load</b> command is executed, Jobs will be created to perform the loading for each cluster that matches the selector filter.</div><div class="section-body-text">If you include the <b>--policies</b> flag, any specified policies will be applied prior to the data being loaded. For example:</div><pre class="code-block">pgo load --policies="rlspolicy,xrayapp" --load-config=$COROOT/examples/sample-load-config.json --selector=name=mycluster</pre><div class="section-body-text">Likewise you can load a sample json file into a database as follows:</div><pre class="code-block">pgo load --policies=jsonload --load-config=$COROOT/examples/sample-json-load-config.json  --selector=name=mycluster</pre><div class="section-body-text">The load configuration file has the following YAML attributes:</div><table class="table"><caption class="table-title">Table 1. Load Configuration File Definitions</caption><tr class="table-header-row"><th class="table-header-left">COImagePrefix</th><th class="table-header-left">the pgo-load image prefix to use for the load job</th></tr><tr class="table-row"><td class="table-data-left">COImageTag</td><td class="table-data-left">the pgo-load image tag to use for the load job</td></tr><tr class="table-row"><td class="table-data-left">DbDatabase</td><td class="table-data-left">the database schema to use for loading the data</td></tr><tr class="table-row"><td class="table-data-left">DbUser</td><td class="table-data-left">the database user to use for loading the data</td></tr><tr class="table-row"><td class="table-data-left">DbPort</td><td class="table-data-left">the database port of the database to load</td></tr><tr class="table-row"><td class="table-data-left">TableToLoad</td><td class="table-data-left">the PostgreSQL table to load</td></tr><tr class="table-row"><td class="table-data-left">FilePath</td><td class="table-data-left">the name of the file to be loaded</td></tr><tr class="table-row"><td class="table-data-left">FileType</td><td class="table-data-left">either csv or json, determines the type of data to be loaded</td></tr><tr class="table-row"><td class="table-data-left">PVCName</td><td class="table-data-left">the name of the PVC that holds the data file to be loaded</td></tr><tr class="table-row"><td class="table-data-left">SecurityContext</td><td class="table-data-left">either fsGroup or SupplementalGroup values</td></tr></table></div></div><div class="section2"><a id="_pgo_commands/_pgo_failover"></a><div class="section2-header"><div class="section2-number">1.18</div><div class="section2-title">pgo failover</div></div><div class="section-body"><div class="section-body-text">Starting with Release 2.6, there is a manual failover command which can be used to promote a replica to a primary role in a PostgreSQL cluster.</div><div class="section-body-text">This process includes the following actions: * pick a target replica to become the new primary * delete the current primary deployment to avoid user requests from going to multiple primary databases (split brain) * promote the targeted replica using <b>pg_ctl promote</b>, this will cause PostgreSQL to go into read-write mode * re-label the targeted replica to use the primary labels, this will match the primary service selector and cause new requests to the primary to be routed to the new primary (targeted replica)</div><div class="section-body-text">The command works like this:</div><pre class="code-block">pgo failover mycluster --query</pre><div class="section-body-text">That command will show you a list of replica targets you can choose to failover to. You will select one of those for the following command:</div><pre class="code-block">pgo failover mycluster --target=mycluster-abxq</pre><div class="section-body-text">There is a CRD called <b>pgtask</b> that will hold the failover request and also the status of that request. You can view the status by viewing it:</div><pre class="code-block">kubectl get pgtasks mycluster-failover -o yaml</pre><div class="section-body-text">Once completed, you will see a new replica has been started to replace the promoted replica, this happens automatically due to the re-lable, the Deployment will recreate its pod because of this. The failover typically takes only a few seconds, however, the creation of the replacement replica can take longer depending on how much data is being replicated.</div></div></div></div></div><div class="page-footer text-center">Prepared by Crunchy Data Solutions, Inc. &mdash; April 5, 2018</div></div></div></div></body></html>