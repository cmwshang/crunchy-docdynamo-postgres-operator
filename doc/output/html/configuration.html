<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>PostgreSQL Operator Configuration</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta><meta property="og:site_name" content="Crunchy Postgres Operator"></meta><meta property="og:title" content="PostgreSQL Operator Configuration"></meta><meta property="og:type" content="website"></meta><meta property="og:image:type" content="image/png"></meta><meta property="og:image" content="{[backrest-url-base]}/logo.svg"></meta><meta name="description" content="PostgreSQL Operator Configuration"></meta><meta property="og:description" content="PostgreSQL Operator Configuration"></meta><link rel="stylesheet" href="default.css" type="text/css"></link></head><body><div id="header-wrapper"><div class="page-header" id="page-header"><div class="page-header-logo"><img src="logo.svg"></div><div class="page-header-title">PostgreSQL Operator Configuration</div></div><div class="page-menu"><div class="menu-body"><div class="menu"><a class="menu-link" href="configuration.html">Configuration</a></div><div class="menu"><a class="menu-link" href="commands.html">Commands</a></div><div class="menu"><a class="menu-link" href="design.html">Design</a></div><div class="menu"><a class="menu-link" href="install.html">Install</a></div><div class="menu"><a class="menu-link" href="quickstarts.html">Quickstarts</a></div></div></div></div><div id="content-wrapper"><div id="sidebar-wrapper"><div id="sidebar"><div class="page-toc"><div class="page-toc-header"><div class="page-toc-title"></div></div><div class="page-toc-body"><div class="section1-toc"><div class="section1-toc-number">1</div><div class="section1-toc-title"><a href="#_overview">Overview</a></div></div><div class="section1-toc"><div class="section1-toc-number">2</div><div class="section1-toc-title"><a href="#_openshift_container_platform">Openshift Container Platform</a></div></div><div class="section1-toc"><div class="section1-toc-number">3</div><div class="section1-toc-title"><a href="#_security_configuration">Security Configuration</a></div><div class="section2-toc"><div class="section2-toc-number">3.1</div><div class="section2-toc-title"><a href="#_security_configuration/_kube_rbac">Kube RBAC</a></div></div><div class="section2-toc"><div class="section2-toc-number">3.2</div><div class="section2-toc-title"><a href="#_security_configuration/_basic_authentication">Basic Authentication</a></div></div><div class="section2-toc"><div class="section2-toc-number">3.3</div><div class="section2-toc-title"><a href="#_security_configuration/_configure_tls">Configure TLS</a></div></div><div class="section2-toc"><div class="section2-toc-number">3.4</div><div class="section2-toc-title"><a href="#_security_configuration/_pgo_rbac">pgo RBAC</a></div></div><div class="section2-toc"><div class="section2-toc-number">3.5</div><div class="section2-toc-title"><a href="#_security_configuration/_b_apiserver_b_configuration"><b>apiserver</b> Configuration</a></div></div><div class="section2-toc"><div class="section2-toc-number">3.6</div><div class="section2-toc-title"><a href="#_security_configuration/_b_postgres_operator_b_container_configuration"><b>postgres-operator</b> Container Configuration</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">4</div><div class="section1-toc-title"><a href="#_bash_completion">bash Completion</a></div></div><div class="section1-toc"><div class="section1-toc-number">5</div><div class="section1-toc-title"><a href="#_rest_api">REST API</a></div></div><div class="section1-toc"><div class="section1-toc-number">6</div><div class="section1-toc-title"><a href="#_deploying_pgpool">Deploying pgpool</a></div></div></div></div></div></div><div id="page-wrapper"><div id="page-body"><div class="section1"><a id="_overview"></a><div class="section1-header"><div class="section1-number">1</div><div class="section1-title">Overview</div></div><div class="section-body"><div class="section-body-text">This document describes how to configure the operator beyond the default configurations and what the configuration settings mean.</div></div></div><div class="section1"><a id="_openshift_container_platform"></a><div class="section1-header"><div class="section1-number">2</div><div class="section1-title">Openshift Container Platform</div></div><div class="section-body"><div class="section-body-text">To run the Operator on Openshift Container Platform note the following:</div><ul class="list-unordered"><li class="list-unordered">Openshift Container Platform 3.7 or greater is required since the Operator is based on Custom Resource Definitions which were first supported in OCP starting with version 3.7</li><li class="list-unordered">the OC_CMD environment variable should be set to <b>oc</b> when operating in an Openshift environment</li></ul></div></div><div class="section1"><a id="_security_configuration"></a><div class="section1-header"><div class="section1-number">3</div><div class="section1-title">Security Configuration</div></div><div class="section-body"><div class="section2"><a id="_security_configuration/_kube_rbac"></a><div class="section2-header"><div class="section2-number">3.1</div><div class="section2-title">Kube RBAC</div></div><div class="section-body"><div class="section-body-text">The <b>apiserver</b> and <b>postgres-operator</b> containers access Kube resources and need priviledges for interacting with Kube. The <b>rbac.yaml</b> file includes a set of roles and bindings that allow the operator to work. These are fine grained controls that you can adjust to your local Kube cluster depending on your security requirements</div><div class="section-body-text">The <b>rbac.yaml</b> file gets executed when you deploy the operator to your Kube cluster.</div><div class="section-body-text">Permissions are granted to the Operator by means of a Service Account called <b>postgres-operator</b>. That service account is added to the Operator deployment.</div><div class="section-body-text">If you are not using the <b>demo</b> namespace, you will edit the following:</div><ul class="list-unordered"><li class="list-unordered">$COROOT/deploy/service-account.yaml</li></ul><div class="section-body-text">See <a href="https://kubernetes.io/docs/admin/authorization/rbac/">here</a> for more details on how to enable RBAC roles and modify the scope of the permissions to suit your needs.</div></div></div><div class="section2"><a id="_security_configuration/_basic_authentication"></a><div class="section2-header"><div class="section2-number">3.2</div><div class="section2-title">Basic Authentication</div></div><div class="section-body"><div class="section-body-text">Basic Authentication is required by the <b>apiserver</b>. You will configure the <b>pgo</b> client to specify a basic authentication username and password by creating a file in the user's home directory named <b>.pgouser</b> that looks similar to this, containing only a single line:</div><pre class="code-block">username:password</pre><div class="section-body-text">This example specifies a username of <b>username</b> and a password of <b>password</b>. These values will be read by the <b>pgo</b> client and passed to the <b>apiserver</b> on each REST API call.</div><div class="section-body-text">For the <b>apiserver</b>, a list of usernames and passwords is specified in the <b>apiserver-conf-secret</b> Secret. The values specified in a deployment are found in the following location:</div><pre class="code-block">$COROOT/conf/apiserver/pgouser</pre><div class="section-body-text">The sample configuration for <b>pgouser</b> is as follows:</div><pre class="code-block">username:password
testuser:testpass</pre><div class="section-body-text">Modify these values to be unique to your environment.</div><div class="section-body-text">If the username and password passed by clients to the <b>apiserver</b> do not match, the REST call will fail and a log message will be produced in the <b>apiserver</b> container log. The client will receive a 401 http status code if they are not able to authenticate.</div><div class="section-body-text">If the <b>pgouser</b> file is not found in the home directory of the <b>pgo</b> user then the next searched location is <b>/etc/pgo/pgouser</b>, and if not found there then lastly the <b>PGOUSER</b> environment variable is searched for a path to the basic authentication file.</div><div class="section-body-text">You can turn off Basic Authentication entirely if you set the BasicAuth setting in the pgo.yaml configuration file to false.</div></div></div><div class="section2"><a id="_security_configuration/_configure_tls"></a><div class="section2-header"><div class="section2-number">3.3</div><div class="section2-title">Configure TLS</div></div><div class="section-body"><div class="section-body-text">TLS is used to secure communications to the <b>apiserver</b>. Sample keys/certs used by TLS are found here:</div><pre class="code-block">$COROOT/conf/apiserver/server.crt
$COROOT/conf/apiserver/server.key</pre><div class="section-body-text">If you want to generate your own keys, you can use the script found in:</div><pre class="code-block">$COROOT/bin/make-certs.sh</pre><div class="section-body-text">The <b>pgo</b> client is required to use keys to connect to the <b>apiserver</b>. Specify the keys to <b>pgo</b> by setting the following environment variables:</div><pre class="code-block">export PGO_CA_CERT=$COROOT/conf/apiserver/server.crt
export PGO_CLIENT_CERT=$COROOT/conf/apiserver/server.crt
export PGO_CLIENT_KEY=$COROOT/conf/apiserver/server.key</pre><div class="section-body-text">The sample server keys are used as the client keys, adjust to suit your requirements.</div><div class="section-body-text">For the <b>apiserver</b> TLS configuration, the keys are included in the <b>apiserver-conf-secret</b> Secret when the <b>apiserver</b> is deployed. See the $COROOT/deploy/deploy.sh script which is where the secret is created.</div><div class="section-body-text">The <b>apiserver</b> listens on port 8443 (e.g. <a href="https://postgres-operator:8443">https://postgres-operator:8443</a>).</div><div class="section-body-text">You can set <b>InsecureSkipVerify</b> to true if you set the NO_TLS_VERIFY environment variable in the <b>deployment.json</b> file to <b>true</b>. By default this value is set to <b>false</b> if you do not specify a value.</div></div></div><div class="section2"><a id="_security_configuration/_pgo_rbac"></a><div class="section2-header"><div class="section2-number">3.4</div><div class="section2-title">pgo RBAC</div></div><div class="section-body"><div class="section-body-text">The <b>pgo</b> command line utility talks to the <b>apiserver</b> REST API instead of the Kube API. Therefore it requires its own RBAC configuration.</div><div class="section-body-text">Starting in Release 2.6, the <b>/conf/apiserver/pgorole</b> is used to define some sample pgo roles, <b>pgadmin</b> and <b>pgoreader</b>.</div><div class="section-body-text">These roles are meant as samples that you can configure to suite your own security requirements. The <b>pgadmin</b> role grants a user authorization to all pgo commands. The <b>pgoreader</b> only grants access to pgo commands that display information such as <b>pgo show cluster</b>.</div><div class="section-body-text">The <b>pgorole</b> file is read at start up time when the operator is deployed to your Kube cluster.</div><div class="section-body-text">Also, the <b>pguser</b> file now includes the role that is assigned to a specific user as follows:</div><pre class="code-block">username:password:pgoadmin
testuser:testpass:pgoadmin
readonlyuser:testpass:pgoreader</pre><div class="section-body-text">The following list shows the current <b>pgo</b> permissions: .pgo Permissions</div><table class="table"><tr class="table-header-row"><th class="table-header-left">Permission</th><th class="table-header-left">Description</th></tr><tr class="table-row"><td class="table-data-left">ShowCluster</td><td class="table-data-left">allow <b>pgo show cluster</b></td></tr><tr class="table-row"><td class="table-data-left">CreateCluster</td><td class="table-data-left">allow <b>pgo create cluster</b></td></tr><tr class="table-row"><td class="table-data-left">TestCluster</td><td class="table-data-left">allow <b>pgo test mycluster</b></td></tr><tr class="table-row"><td class="table-data-left">ShowBackup</td><td class="table-data-left">allow <b>pgo show backup</b></td></tr><tr class="table-row"><td class="table-data-left">CreateBackup</td><td class="table-data-left">allow <b>pgo backup mycluster</b></td></tr><tr class="table-row"><td class="table-data-left">DeleteBackup</td><td class="table-data-left">allow <b>pgo delete backup mycluster</b></td></tr><tr class="table-row"><td class="table-data-left">Label</td><td class="table-data-left">allow <b>pgo label</b></td></tr><tr class="table-row"><td class="table-data-left">Load</td><td class="table-data-left">allow <b>pgo load</b></td></tr><tr class="table-row"><td class="table-data-left">CreatePolicy</td><td class="table-data-left">allow <b>pgo create policy</b></td></tr><tr class="table-row"><td class="table-data-left">DeletePolicy</td><td class="table-data-left">allow <b>pgo delete policy</b></td></tr><tr class="table-row"><td class="table-data-left">ShowPolicy</td><td class="table-data-left">allow <b>pgo show policy</b></td></tr><tr class="table-row"><td class="table-data-left">ApplyPolicy</td><td class="table-data-left">allow <b>pgo apply policy</b></td></tr><tr class="table-row"><td class="table-data-left">ShowPVC</td><td class="table-data-left">allow <b>pgo show pvc</b></td></tr><tr class="table-row"><td class="table-data-left">CreateUpgrade</td><td class="table-data-left">allow <b>pgo upgrade</b></td></tr><tr class="table-row"><td class="table-data-left">ShowUpgrade</td><td class="table-data-left">allow <b>pgo show upgrade</b></td></tr><tr class="table-row"><td class="table-data-left">DeleteUpgrade</td><td class="table-data-left">allow <b>pgo delete upgrade</b></td></tr><tr class="table-row"><td class="table-data-left">CreateUser</td><td class="table-data-left">allow <b>pgo create user</b></td></tr><tr class="table-row"><td class="table-data-left">CreateFailover</td><td class="table-data-left">allow <b>pgo failover</b></td></tr><tr class="table-row"><td class="table-data-left">User</td><td class="table-data-left">allow <b>pgo user</b></td></tr><tr class="table-row"><td class="table-data-left">Version</td><td class="table-data-left">allow <b>pgo version</b></td></tr></table><div class="section-body-text">If you are not authorized for a <b>pgo</b> command the user will get back this response:</div><pre class="code-block">FATA[0000] Authentication Failed: 40</pre></div></div><div class="section2"><a id="_security_configuration/_b_apiserver_b_configuration"></a><div class="section2-header"><div class="section2-number">3.5</div><div class="section2-title"><b>apiserver</b> Configuration</div></div><div class="section-body"><div class="section-body-text">The <b>postgres-operator</b> pod includes the <b>apiserver</b> which is a REST API that <b>pgo</b> users communicate with.</div><div class="section-body-text">The <b>apiserver</b> uses the following configuration files found in $COROOT/conf/apiserver to determine how the Operator will provision PostgreSQL containers:</div><pre class="code-block">$COROOT/conf/apiserver/pgo.yaml
$COROOT/conf/apiserver/pgo.lspvc-template.json
$COROOT/conf/apiserver/pgo.load-template.json</pre><div class="section-body-text">Note that the default <b>pgo.yaml</b> file assumes you are going to use <b>HostPath</b> Persistent Volumes for your storage configuration. Adjust this file for NFS or other storage configurations.</div><div class="section-body-text">The version of PostgreSQL container the Operator will deploy is determined by the <b>CCPImageTag</b> setting in the <b>$COROOT/conf/apiserver/pgo.yaml</b> configuration file. By default, this value is set to the latest release of the Crunchy Container Suite.</div><div class="section3"><a id="_security_configuration/_b_apiserver_b_configuration/_b_pgo_yaml_b"></a><div class="section3-header"><div class="section3-number">3.5.1</div><div class="section3-title"><b>pgo.yaml</b></div></div><div class="section-body"><div class="section-body-text">The default <b>pgo.yaml</b> configuration file, included in <b>$COROOT/conf/apiserver/pgo.yaml</b>, looks like this:</div><pre class="code-block">BasicAuth:  true
Cluster:
  CCPImageTag:  centos7-10.3-1.8.2
  Port:  5432
  User:  testuser
  Database:  userdb
  PasswordAgeDays:  60
  PasswordLength:  8
  Strategy:  1
  Replicas:  0
PrimaryStorage: storage1
BackupStorage: storage1
ReplicaStorage: storage1
Storage:
  storage1:
    AccessMode:  ReadWriteMany
    Size:  200M
    StorageType:  create
  storage2:
    AccessMode:  ReadWriteMany
    Size:  333M
    StorageType:  create
  storage3:
    AccessMode:  ReadWriteMany
    Size:  440M
    StorageType:  create
DefaultContainerResource: small
ContainerResources:
  small:
    RequestsMemory:  2Gi
    RequestsCPU:  0.5
    LimitsMemory:  2Gi
    LimitsCPU:  1.0
  large:
    RequestsMemory:  8Gi
    RequestsCPU:  2.0
    LimitsMemory:  12Gi
    LimitsCPU:  4.0
Pgo:
  Audit:  false
  Metrics:  false
  LSPVCTemplate:  /config/pgo.lspvc-template.json
  CSVLoadTemplate:  /config/pgo.load-template.json
  COImagePrefix:  crunchydata
  COImageTag:  centos7-2.6</pre><div class="section-body-text">Values in the pgo configuration file have the following meaning:</div><table class="table"><caption class="table-title">Table 1. pgo Configuration File Definitions</caption><tr class="table-header-row"><th class="table-header-left">Setting</th><th class="table-header-left">Definition</th></tr><tr class="table-row"><td class="table-data-left">BasicAuth</td><td class="table-data-left">if set to <b>true</b> will enable Basic Authentication</td></tr><tr class="table-row"><td class="table-data-left">Cluster.CCPImageTag</td><td class="table-data-left">newly created containers will be based on this image version (e.g. centos7-10.3-1.8.1), unless you override it using the --ccp-image-tag command line flag</td></tr><tr class="table-row"><td class="table-data-left">Cluster.Port</td><td class="table-data-left">the PostgreSQL port to use for new containers (e.g. 5432)</td></tr><tr class="table-row"><td class="table-data-left">Cluster.User</td><td class="table-data-left">the PostgreSQL normal user name</td></tr><tr class="table-row"><td class="table-data-left">Cluster.Strategy</td><td class="table-data-left">sets the deployment strategy to be used for deploying a cluster, currently there is only strategy <b>1</b></td></tr><tr class="table-row"><td class="table-data-left">Cluster.Replicas</td><td class="table-data-left">the number of cluster replicas to create for newly created clusters</td></tr><tr class="table-row"><td class="table-data-left">Cluster.Policies</td><td class="table-data-left">optional, list of policies to apply to a newly created cluster, comma separated, must be valid policies in the catalog</td></tr><tr class="table-row"><td class="table-data-left">Cluster.PasswordAgeDays</td><td class="table-data-left">optional, if set, will set the VALID UNTIL date on passwords to this many days in the future when creating users or setting passwords, defaults to 60 days</td></tr><tr class="table-row"><td class="table-data-left">Cluster.PasswordLength</td><td class="table-data-left">optional, if set, will determine the password length used when creating passwords, defaults to 8</td></tr><tr class="table-row"><td class="table-data-left">PrimaryStorage</td><td class="table-data-left">required, the value of the storage configuration to use for the primary PostgreSQL deployment</td></tr><tr class="table-row"><td class="table-data-left">BackupStorage</td><td class="table-data-left">required, the value of the storage configuration to use for backups</td></tr><tr class="table-row"><td class="table-data-left">ReplicaStorage</td><td class="table-data-left">required, the value of the storage configuration to use for the replica PostgreSQL deployments</td></tr><tr class="table-row"><td class="table-data-left">Storage.storage1.StorageClass</td><td class="table-data-left">for a dynamic storage type, you can specify the storage class used for storage provisioning(e.g. standard, gold, fast)</td></tr><tr class="table-row"><td class="table-data-left">Storage.storage1.AccessMode</td><td class="table-data-left">the access mode for new PVCs (e.g. ReadWriteMany, ReadWriteOnce, ReadOnlyMany). See below for descriptions of these.</td></tr><tr class="table-row"><td class="table-data-left">Storage.storage1.Size</td><td class="table-data-left">the size to use when creating new PVCs (e.g. 100M, 1Gi)</td></tr><tr class="table-row"><td class="table-data-left">Storage.storage1.StorageType</td><td class="table-data-left">supported values are either <b>dynamic</b>, <b>existing</b>, <b>create</b>, or <b>emptydir</b>, if not supplied, <b>emptydir</b> is used</td></tr><tr class="table-row"><td class="table-data-left">Storage.storage1.Fsgroup</td><td class="table-data-left">optional, if set, will cause a <b>SecurityContext</b> and <b>fsGroup</b> attributes to be added to generated Pod and Deployment definitions</td></tr><tr class="table-row"><td class="table-data-left">Storage.storage1.SupplementalGroups</td><td class="table-data-left">optional, if set, will cause a SecurityContext to be added to generated Pod and Deployment definitions</td></tr><tr class="table-row"><td class="table-data-left">DefaultContainerResource</td><td class="table-data-left">optional, the value of the container resources configuration to use for all database containers, if not set, no resource limits or requests are added on the database container</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.small.RequestsMemory</td><td class="table-data-left">request size of memory in bytes</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.small.RequestsCPU</td><td class="table-data-left">request size of CPU cores</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.small.LimitsMemory</td><td class="table-data-left">request size of memory in bytes</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.small.LimitsCPU</td><td class="table-data-left">request size of CPU cores</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.large.RequestsMemory</td><td class="table-data-left">request size of memory in bytes</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.large.RequestsCPU</td><td class="table-data-left">request size of CPU cores</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.large.LimitsMemory</td><td class="table-data-left">request size of memory in bytes</td></tr><tr class="table-row"><td class="table-data-left">ContainerResources.large.LimitsCPU</td><td class="table-data-left">request size of CPU cores</td></tr><tr class="table-row"><td class="table-data-left">Pgo.LSPVCTemplate</td><td class="table-data-left">the PVC lspvc template file that lists PVC contents</td></tr><tr class="table-row"><td class="table-data-left">Pgo.LoadTemplate</td><td class="table-data-left">the load template file used for load jobs</td></tr><tr class="table-row"><td class="table-data-left">Pgo.COImagePrefix</td><td class="table-data-left">image tag prefix to use for the Operator containers</td></tr><tr class="table-row"><td class="table-data-left">Pgo.COImageTag</td><td class="table-data-left">image tag to use for the Operator containers</td></tr><tr class="table-row"><td class="table-data-left">Pgo.Audit</td><td class="table-data-left">boolean, if set to true will cause each apiserver call to be logged with an <b>audit</b> marking</td></tr><tr class="table-row"><td class="table-data-left">Pgo.Metrics</td><td class="table-data-left">boolean, if set to true will cause each new cluster to include crunchy-collect as a sidecar container for metrics collection, if set to false (default), users can still add metrics on a cluster-by-cluster basis using the pgo command flag --metrics</td></tr></table></div></div><div class="section3"><a id="_security_configuration/_b_apiserver_b_configuration/_storage_configurations"></a><div class="section3-header"><div class="section3-number">3.5.2</div><div class="section3-title">Storage Configurations</div></div><div class="section-body"><div class="section-body-text">You can now define n-number of Storage configurations within the <b>pgo.yaml</b> file. Those Storage configurations follow these conventions:</div><ul class="list-unordered"><li class="list-unordered">they must have lowercase name (e.g. storage1)</li><li class="list-unordered">they must be unique names (e.g. mydrstorage, faststorage, slowstorage)</li></ul><div class="section-body-text">These Storage configurations are referenced in the BackupStorage, ReplicaStorage, and PrimaryStorage configuration values. However, there are command line options in the <b>pgo</b> client that will let a user override these default global values to offer you the user a way to specify very targeted storage configurations when needed (e.g. disaster recovery storage for certain backups).</div><div class="section-body-text">You can set the storage AccessMode values to the following:</div><ul class="list-unordered"><li class="list-unordered"><b>ReadWriteMany</b> - mounts the volume as read-write by many nodes</li><li class="list-unordered"><b>ReadWriteOnce</b> - mounts the PVC as read-write by a single node</li><li class="list-unordered"><b>ReadOnlyMany</b> - mounts the PVC as read-only by many nodes</li></ul><div class="section-body-text">These Storage configurations are validated when the <b>pgo-apiserver</b> starts, if a non-valid configuration is found, the apiserver will abort. These Storage values are only read at <b>apiserver</b> start time.</div><div class="section-body-text">The following StorageType values are possible:</div><ul class="list-unordered"><li class="list-unordered"><b>dynamic</b> - this will allow for dynamic provisioning of storage using a StorageClass.</li><li class="list-unordered"><b>existing</b> - This setting allows you to use a PVC that already exists. For example, if you have a NFS volume mounted to a PVC, all PostgreSQL clusters can write to that NFS volume mount via a common PVC. When set, the Name setting is used for the PVC.</li><li class="list-unordered"><b>create</b> - This setting allows for the creation of a new PVC for each PostgreSQL cluster using a naming convention of <b>clustername</b>-pvc*. When set, the <b>Size</b>, <b>AccessMode</b> settings are used in constructing the new PVC.</li><li class="list-unordered"><b>emptydir</b> - If a StorageType value is not defined, <b>emptydir</b> is used by default. This is a volume type that's created when a pod is assigned to a node and exists as long as that pod remains running on that node; it is deleted as soon as the pod is manually deleted or removed from the node.</li></ul><div class="section-body-text">The operator will create new PVCs using this naming convention: <b>dbname-pvc</b> where <b>dbname</b> is the database name you have specified. For example, if you run:</div><pre class="code-block">pgo create cluster example1</pre><div class="section-body-text">It will result in a PVC being created named <b>example1-pvc</b> and in the case of a backup job, the pvc is named <b>example1-backup-pvc</b></div><div class="section-body-text">There are currently 3 sample pgo configuration files provided for users to use as a starting configuration:</div><ul class="list-unordered"><li class="list-unordered">pgo.yaml.emptydir - this configuration specifies <b>emptydir</b> storage to be used for databases</li><li class="list-unordered">pgo.yaml.nfs - this configuration specifies <b>create</b> storage to be used, this is used for NFS storage for example where you want to have a unique PVC created for each database</li><li class="list-unordered">pgo.yaml.dynamic - this configuration specifies <b>dynamic</b> storage to be used, namely a <b>storageclass</b> that refers to a dynamic provisioning strorage such as StorageOS or Portworx, or GCE.</li></ul></div></div><div class="section3"><a id="_security_configuration/_b_apiserver_b_configuration/_overriding_container_resources_configuration_defaults"></a><div class="section3-header"><div class="section3-number">3.5.3</div><div class="section3-title">Overriding Container Resources Configuration Defaults</div></div><div class="section-body"><div class="section-body-text">In the <b>pgo.yaml</b> configuration file you have the option to configure a default container resources configuration that when set will add CPU and memory resource limits and requests values into each database container when the container is created.</div><div class="section-body-text">You can also override the default value using the <b>--resources-config</b> command flag when creating a new cluster:</div><pre class="code-block">pgo create cluster testcluster --resources-config=large</pre><div class="section-body-text">Note, if you try to allocate more resources than your host or Kube cluster has available then you will see your pods wait in a <b>Pending</b> status. The output from a <b>kubectl describe pod</b> command will show output like this in this case:</div><pre class="code-block">Events:
  Type     Reason            Age               From               Message
  ----     ------            ----              ----               -------
  Warning  FailedScheduling  49s (x8 over 1m)  default-scheduler  No nodes are available that match all of the predicates: Insufficient memory (1).</pre></div></div><div class="section3"><a id="_security_configuration/_b_apiserver_b_configuration/_overriding_storage_configuration_defaults"></a><div class="section3-header"><div class="section3-number">3.5.4</div><div class="section3-title">Overriding Storage Configuration Defaults</div></div><div class="section-body"><pre class="code-block">pgo create cluster testcluster --storage-config=bigdisk</pre><div class="section-body-text">That example will create a cluster and specify a storage configuration of <b>bigdisk</b> to be used for the primary database storage, the replica storage will default to the value of ReplicaStorage as specified in <b>pgo.yaml</b>.</div><pre class="code-block">pgo create cluster testcluster2 --storage-config=fastdisk --replica-storage-config=slowdisk</pre><div class="section-body-text">That example will create a cluster and specify a storage configuration of <b>fastdisk</b> to be used for the primary database storage, the replica storage will use the storage configuration <b>slowdisk</b>.</div><pre class="code-block">pgo backup testcluster --storage-config=offsitestorage</pre><div class="section-body-text">That example will create a backup and use the <b>offsitestorage</b> storage configuration for persisting the backup.</div></div></div><div class="section3"><a id="_security_configuration/_b_apiserver_b_configuration/_disaster_recovery_using_storage_configurations"></a><div class="section3-header"><div class="section3-number">3.5.5</div><div class="section3-title">Disaster Recovery Using Storage Configurations</div></div><div class="section-body"><div class="section-body-text">A simple mechanism for partial disaster recovery can be obtained by leveraging network storage, Kubernetes storage classes, and the storage configuration options within the Operator.</div><div class="section-body-text">For example, if you define a Kubernetes storage class that refers to a storage backend that is running within your disaster recovery site, and then use that storage class as a storage configuration for your backups, you essentially have moved your backup files automatically to your DR site thanks to network storage.</div><div class="imageblock"><img src="../image/Operator-DR-Storage.png?raw=true" alt="Operator-DR-Storage.png?raw=true" /></div></div></div></div></div><div class="section2"><a id="_security_configuration/_b_postgres_operator_b_container_configuration"></a><div class="section2-header"><div class="section2-number">3.6</div><div class="section2-title"><b>postgres-operator</b> Container Configuration</div></div><div class="section-body"><div class="section-body-text">To enable <b>debug</b> level messages from the operator pod, set the <b>CRUNCHY_DEBUG</b> environment variable to <b>true</b> within its deployment file <b>deployment.json</b>.</div><div class="section3"><a id="_security_configuration/_b_postgres_operator_b_container_configuration/_operator_templates"></a><div class="section3-header"><div class="section3-number">3.6.1</div><div class="section3-title">Operator Templates</div></div><div class="section-body"><div class="section-body-text">The database and cluster Kubernetes objects that get created by the operator are based on json templates that are added into the operator deployment by means of a mounted volume.</div><div class="section-body-text">The templates are located in the <b>$COROOT/conf/postgres-operator</b> directory and get added into a config map which is mounted by the operator deployment.</div></div></div></div></div></div></div><div class="section1"><a id="_bash_completion"></a><div class="section1-header"><div class="section1-number">4</div><div class="section1-title">bash Completion</div></div><div class="section-body"><div class="section-body-text">There is a bash completion file that is included for users to try, this is located in the repository at <b>example/pgo-bash-completion</b>. To use it:</div><pre class="code-block">cp $COROOT/example/pgo-bash-completion /etc/bash_completion.d/pgo
su - $USER</pre></div></div><div class="section1"><a id="_rest_api"></a><div class="section1-header"><div class="section1-number">5</div><div class="section1-title">REST API</div></div><div class="section-body"><div class="section-body-text">Because the <b>apiserver</b> implements a REST API, you can integrate with it using your own application code. To demonstrate this, the following <b>curl</b> commands show the API usage:</div><div class="section-body-text"><b>pgo version</b></div><pre class="code-block">curl -v -X GET -u readonlyuser:testpass -H "Content-Type: application/json" --insecure https://10.101.155.218:8443/version</pre><div class="section-body-text"><b>pgo show policy all</b></div><pre class="code-block">curl -v -X GET -u readonlyuser:testpass -H "Content-Type: application/json" --insecure https://10.101.155.218:8443/policies/all</pre><div class="section-body-text"><b>pgo show pvc danger-pvc</b></div><pre class="code-block">curl -v -X GET -u readonlyuser:testpass -H "Content-Type: application/json" --insecure https://10.101.155.218:8443/pvc/danger-pvc</pre><div class="section-body-text"><b>pgo show cluster mycluster</b></div><pre class="code-block">curl -v -X GET -u readonlyuser:testpass -H "Content-Type: application/json" --insecure https://10.101.155.218:8443/clusters/mycluster</pre><div class="section-body-text"><b>pgo show upgrade mycluster</b></div><pre class="code-block">curl -v -X GET -u readonlyuser:testpass -H "Content-Type: application/json" --insecure https://10.101.155.218:8443/upgrades/mycluster</pre><div class="section-body-text"><b>pgo test mycluster</b></div><pre class="code-block">curl -v -X GET -u readonlyuser:testpass -H "Content-Type: application/json" --insecure https://10.101.155.218:8443/clusters/test/mycluster</pre><div class="section-body-text"><b>pgo show backup mycluster</b></div><pre class="code-block">curl -v -X GET -u readonlyuser:testpass -H "Content-Type: application/json" --insecure https://10.101.155.218:8443/backups/mycluster</pre></div></div><div class="section1"><a id="_deploying_pgpool"></a><div class="section1-header"><div class="section1-number">6</div><div class="section1-title">Deploying pgpool</div></div><div class="section-body"><div class="section-body-text">It is optional but you can cause a pgpool Deployment to be created as part of a Postgres cluster. Running pgpool only makes sense when you have both a primary and some number of replicas deployed as part of your Postgres cluster. The current pgpool configuration deployed by the operator only works when you have both a primary and replica running.</div><div class="section-body-text">When a user creates the cluster they can pass a command flag as follows:</div><pre class="code-block">pgo create cluster cluster1 --pgpool
pgo scale cluster1</pre><div class="section-body-text">This will cause the operator to create a Deployment that includes the <b>crunchy-pgpool</b> container along with a replica. That container will create a configuration that will perform SQL routing to your cluster services, both for the primary and replica services.</div><div class="section-body-text">Pgpool examines the SQL it receives and routes the SQL statement to either the primary or replica based on the SQL action specifically it will send writes and updates to only the <b>primary</b> service. It will send read-only statements to the <b>replica</b> service.</div><div class="section-body-text">When the operator deploys the pgpool container, it creates a secret (e.g. mycluster-pgpool-secret) that contains pgpool configuration files. It fills out templated versions of these configuration files specifically for this postgres cluster.</div><div class="section-body-text">Part of the pgpool deployment also includes creating a <b>pool_passwd</b> file that will allow the <b>testuser</b> credential to authenticate to pgpool. Adding additional users to the pgpool configuration currently requires human intervention specifically creating a new pgpool secret and bouncing the pgpool pod to pick up the updated secret. Future operator releases will attempt to provide <b>pgo</b> commands to let you automate the addition or removal of a pgpool user.</div><div class="section-body-text">Currently to update a pgpool user within the <b>pool_passwd</b> configuration file, you will have to copy the existing files from the secret to your local system, update the credentials in <b>pool_passwd</b> with your new user credentials, and then recreate the pgpool secret, and finally restart the pgpool pod to pick up the updated configuration files.</div><div class="section-body-text">Example:</div><pre class="code-block">kubectl cp demo/wed10-pgpool-6cc6f6598d-wcnmf:/pgconf/ /tmp/foo</pre><div class="section-body-text">That command gets a running set of secret pgpool configuration files and places them locally on your system for you to edit.</div><div class="section-body-text"><b>pgpool</b> requires a specially formatted password credential to be placed into <b>pool_passwd</b>. There is a golang program included in $COROOT/golang-examples/gen-pgpool-pass.go* that when run will generate the value to use within the <b>pgpool_passwd</b> configuration file.</div><pre class="code-block">go run $COROOT/golang-examples/gen-pgpool-pass.go
Enter Username: testuser
Enter Password:
Password typed: e99Mjt1dLz
hash of password is [md59c4017667828b33762665dc4558fbd76]</pre><div class="section-body-text">The value <b>md59c4017667828b33762665dc4558fbd76</b> is what you will use in the <b>pool_passwd</b> file.</div><div class="section-body-text">Then, create the new secrets file based on those updated files:</div><pre class="code-block">$COROOT/bin/create-pgpool-secrets.sh</pre><div class="section-body-text">Lastly for pgpool to pick up the new secret file, delete the existing deployment pod:</div><pre class="code-block">kubectl get deployment wed-pgpool
kubectl delete pod wed10-pgpool-6cc6f6598d-wcnmf</pre><div class="section-body-text">The pgpool deployment will spin up another pgpool which will pick up the updated secret file.</div></div></div><div class="page-footer text-center">Prepared by Crunchy Data Solutions, Inc. &mdash; April 5, 2018</div></div></div></div></body></html>